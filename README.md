# Pathauth

  Pathauth is designed to set up fine grained authorizations of resolvers as an orthogonal
  concern without compromising on performances and complexity.

## Getting started

To set up fine grained authorization of your resolver, all you need to do is:
- write authorization resolvers (see below)
- make sure all your resolvers are passed to wrap-resolvers before adding them to pathom env
- add authorizations to your resolvers' config (see below)

## Usage

To add authorization to a resolver you simply add ::pathauth/authorizations to their config.

### Authorization resolver

A classic Pathom resolver whose outputs are authorization attributes that are only returned if the conditions are met.
Inputs can be any arbitrary attribute that is needed to determine that the authorizations are granted.

Those do not have a ::pathauth/authorizations config, their outputs are the attributes you
will use in the ::pathauth/authorizations config of other resolver.

- inputs: inputs-required-for-authorization
- output: authorizations

### Simple resolver with authorization

A resolver that will only be accessed if the attributes passed in ::pa/authorizations are resolving.
The resolver cannot provide an attribute as output that is an input of an authorization resolver.
To achieve this Pathauth will concatenate the authorizations to the inputs of the resolver.
Pathom will do the work for you and figure out the optimal resolutions. If the access to the attributes
is not authorized Pathom will simply not resolve them.

- inputs: (concat resolver-authorizations resolver-inputs)
- outputs: resolver-outputs

### Special resolver with circular dependency between authorization and outputs

To resolve the case of a circular dependency between a resolver that requires an
authorization and that authorization requiring at least one of the outputs of the resolver
as input.
Pathauth will ignore the authorization and nest the outputs within an :pending.{authorization} key.

This alleviates the need to handle these circular dependency on your own. Eg in the
case where you have a resolver by id for an entity with one of the output attributes being
used to determine the authorization.

- inputs resolver-inputs
- outputs [{:pending.{authorization} resolver-outputs}]

### Extra generated resolver

These resolvers are generated by Pathauth for the special resolvers and will simply un-nest the output of a resolver
if the required authorizations are resolved.

- inputs [{:pending.{authorization} resolver-outputs}]
- outputs resolver-outputs

## Library development

Run the project's tests:

    $ clojure -T:build test

Run the project's CI pipeline and build a JAR:

    $ clojure -T:build ci

This will produce an updated `pom.xml` file with synchronized dependencies inside the `META-INF`
directory inside `target/classes` and the JAR in `target`. You can update the version (and SCM tag)
information in generated `pom.xml` by updating `build.clj`.

Install it locally (requires the `ci` task be run first):

    $ clojure -T:build install

Deploy it to Clojars -- needs `CLOJARS_USERNAME` and `CLOJARS_PASSWORD` environment
variables (requires the `ci` task be run first):

    $ clojure -T:build deploy

Your library will be deployed to net.clojars.yenda/pathauth on clojars.org by default.

## License

Copyright Â© 2023 Yenda

Distributed under the Eclipse Public License version 1.0.
